{"ast":null,"code":"export function pluralize(name, count) {\n  if (count === 1) {\n    return name;\n  }\n\n  return name + 's';\n} // function that opens the database connection, creates the object store (if it's the first time using it on the machine) and runs whatever transaction we need to have run on a successful connection\n// So when we call the function, we'll open the connection to the database and then connect to the object store that we pass in as storeName.\n// Then we'll perform a transaction, using the method and object values to help carry it out.\n\nexport function idbPromise(storeName, method, object) {\n  // We also wrap the whole thing in a Promise, making it a lot easier to work with IndexedDB's asynchronous nature.\n  return new Promise((resolve, reject) => {\n    // open connection to the database `shop-shop` with the version of 1\n    const request = window.indexedDB.open('shop-shop', 1); // create variables to hold reference to the database, transaction (tx), and object store\n\n    let db, tx, store; // if version has changed (or if this is the first time using the database), run this method and create the three object stores\n    // Remember that with IndexedDB, the .onupgradeneeded() event only runs if the browser notices that the version number in the .open() method has changed since the last time, or if the browser has never connected to the database before and 1 is the new version. \n    // Any other time this code executes and the version is still 1, the .onupgradeneeded() will not run.\n\n    request.onupgradeneeded = function (e) {\n      const db = request.result; // create object store for each type of data and set \"primary\" key index to be the `_id` of the data\n      //  Last time, we simply let them use their built-in auto increment features. But now, we'd like to provide the actual index value we want to use for looking up data. \n      // Because that index value will be the MongoDB _id property for each product or category, it makes sense to set the keyPath name to _id.\n\n      db.createObjectStore('products', {\n        keyPath: '_id'\n      });\n      db.createObjectStore('categories', {\n        keyPath: '_id'\n      });\n      db.createObjectStore('cart', {\n        keyPath: '_id'\n      });\n    }; // handle any errors with connecting\n\n\n    request.onerror = function (e) {\n      console.log('There was an error');\n    }; // on database open success\n\n\n    request.onsuccess = function (e) {\n      // save a reference of the database to the `db` variable\n      db = request.result; // open a transaction do whatever we pass into `storeName` (must match one of the object store names)\n\n      tx = db.transaction(storeName, 'readwrite'); // save a reference to that object store\n\n      store = tx.objectStore(storeName); // if there's any errors, let us know\n\n      db.onerror = function (e) {\n        console.log('error', e);\n      }; // a switch statement to check what the value of the method is.\n\n\n      switch (method) {\n        // Both the put and get methods will return the data to wherever we call this idbPromise() function.\n        // If it's put, then we run the .put() method on the object store, overwriting any data with the matching _id value from the object and adding it if it can't find a match.       \n        case 'put':\n          store.put(object);\n          resolve(object);\n          break;\n        // If it's get, we'll simply get all data from that store and return it. \n\n        case 'get':\n          const all = store.getAll();\n\n          all.onsuccess = function () {\n            resolve(all.result);\n          };\n\n          break;\n        // If the value is delete, we'll delete that item from the object store. This option will come in handy if users want to remove an item from the shopping cart while offline.\n\n        case 'delete':\n          store.delete(object._id);\n          break;\n\n        default:\n          console.log('No valid method');\n          break;\n      } // when the transaction is complete, close the connection\n\n\n      tx.oncomplete = function () {\n        db.close();\n      };\n    };\n  });\n}\n;","map":{"version":3,"sources":["C:/Users/Ryan&Lindsey/Desktop/projects/shop-shop/client/src/utils/helpers.js"],"names":["pluralize","name","count","idbPromise","storeName","method","object","Promise","resolve","reject","request","window","indexedDB","open","db","tx","store","onupgradeneeded","e","result","createObjectStore","keyPath","onerror","console","log","onsuccess","transaction","objectStore","put","all","getAll","delete","_id","oncomplete","close"],"mappings":"AAAA,OAAO,SAASA,SAAT,CAAmBC,IAAnB,EAAyBC,KAAzB,EAAgC;AACrC,MAAIA,KAAK,KAAK,CAAd,EAAiB;AACf,WAAOD,IAAP;AACD;;AACD,SAAOA,IAAI,GAAG,GAAd;AACD,C,CAED;AACA;AACA;;AACA,OAAO,SAASE,UAAT,CAAoBC,SAApB,EAA+BC,MAA/B,EAAuCC,MAAvC,EAA+C;AACpD;AACA,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC;AACA,UAAMC,OAAO,GAAGC,MAAM,CAACC,SAAP,CAAiBC,IAAjB,CAAsB,WAAtB,EAAmC,CAAnC,CAAhB,CAFsC,CAItC;;AACA,QAAIC,EAAJ,EAAQC,EAAR,EAAYC,KAAZ,CALsC,CAOtC;AACA;AACA;;AACAN,IAAAA,OAAO,CAACO,eAAR,GAA0B,UAASC,CAAT,EAAY;AACpC,YAAMJ,EAAE,GAAGJ,OAAO,CAACS,MAAnB,CADoC,CAEpC;AACA;AACA;;AACAL,MAAAA,EAAE,CAACM,iBAAH,CAAqB,UAArB,EAAiC;AAAEC,QAAAA,OAAO,EAAE;AAAX,OAAjC;AACAP,MAAAA,EAAE,CAACM,iBAAH,CAAqB,YAArB,EAAmC;AAAEC,QAAAA,OAAO,EAAE;AAAX,OAAnC;AACAP,MAAAA,EAAE,CAACM,iBAAH,CAAqB,MAArB,EAA6B;AAAEC,QAAAA,OAAO,EAAE;AAAX,OAA7B;AACD,KARD,CAVsC,CAoBtC;;;AACAX,IAAAA,OAAO,CAACY,OAAR,GAAkB,UAASJ,CAAT,EAAY;AAC5BK,MAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACD,KAFD,CArBsC,CAyBtC;;;AACAd,IAAAA,OAAO,CAACe,SAAR,GAAoB,UAASP,CAAT,EAAY;AAC9B;AACAJ,MAAAA,EAAE,GAAGJ,OAAO,CAACS,MAAb,CAF8B,CAG9B;;AACAJ,MAAAA,EAAE,GAAGD,EAAE,CAACY,WAAH,CAAetB,SAAf,EAA0B,WAA1B,CAAL,CAJ8B,CAK9B;;AACAY,MAAAA,KAAK,GAAGD,EAAE,CAACY,WAAH,CAAevB,SAAf,CAAR,CAN8B,CAQ9B;;AACAU,MAAAA,EAAE,CAACQ,OAAH,GAAa,UAASJ,CAAT,EAAY;AACvBK,QAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ,EAAqBN,CAArB;AACD,OAFD,CAT8B,CAa9B;;;AACA,cAAQb,MAAR;AACE;AAEA;AACA,aAAK,KAAL;AACEW,UAAAA,KAAK,CAACY,GAAN,CAAUtB,MAAV;AACAE,UAAAA,OAAO,CAACF,MAAD,CAAP;AACA;AAEF;;AACA,aAAK,KAAL;AACE,gBAAMuB,GAAG,GAAGb,KAAK,CAACc,MAAN,EAAZ;;AACAD,UAAAA,GAAG,CAACJ,SAAJ,GAAgB,YAAW;AACzBjB,YAAAA,OAAO,CAACqB,GAAG,CAACV,MAAL,CAAP;AACD,WAFD;;AAGA;AAEA;;AACF,aAAK,QAAL;AACEH,UAAAA,KAAK,CAACe,MAAN,CAAazB,MAAM,CAAC0B,GAApB;AACA;;AAEF;AACET,UAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACA;AAxBJ,OAd8B,CAyC9B;;;AACAT,MAAAA,EAAE,CAACkB,UAAH,GAAgB,YAAW;AACzBnB,QAAAA,EAAE,CAACoB,KAAH;AACD,OAFD;AAGD,KA7CD;AA+CD,GAzEM,CAAP;AA0ED;AAAA","sourcesContent":["export function pluralize(name, count) {\n  if (count === 1) {\n    return name\n  }\n  return name + 's'\n}\n\n// function that opens the database connection, creates the object store (if it's the first time using it on the machine) and runs whatever transaction we need to have run on a successful connection\n// So when we call the function, we'll open the connection to the database and then connect to the object store that we pass in as storeName.\n// Then we'll perform a transaction, using the method and object values to help carry it out.\nexport function idbPromise(storeName, method, object) {\n  // We also wrap the whole thing in a Promise, making it a lot easier to work with IndexedDB's asynchronous nature.\n  return new Promise((resolve, reject) => {\n    // open connection to the database `shop-shop` with the version of 1\n    const request = window.indexedDB.open('shop-shop', 1);\n\n    // create variables to hold reference to the database, transaction (tx), and object store\n    let db, tx, store;\n\n    // if version has changed (or if this is the first time using the database), run this method and create the three object stores\n    // Remember that with IndexedDB, the .onupgradeneeded() event only runs if the browser notices that the version number in the .open() method has changed since the last time, or if the browser has never connected to the database before and 1 is the new version. \n    // Any other time this code executes and the version is still 1, the .onupgradeneeded() will not run.\n    request.onupgradeneeded = function(e) {\n      const db = request.result;\n      // create object store for each type of data and set \"primary\" key index to be the `_id` of the data\n      //  Last time, we simply let them use their built-in auto increment features. But now, we'd like to provide the actual index value we want to use for looking up data. \n      // Because that index value will be the MongoDB _id property for each product or category, it makes sense to set the keyPath name to _id.\n      db.createObjectStore('products', { keyPath: '_id' });\n      db.createObjectStore('categories', { keyPath: '_id' });\n      db.createObjectStore('cart', { keyPath: '_id' });\n    };\n\n    // handle any errors with connecting\n    request.onerror = function(e) {\n      console.log('There was an error');\n    };\n\n    // on database open success\n    request.onsuccess = function(e) {\n      // save a reference of the database to the `db` variable\n      db = request.result;\n      // open a transaction do whatever we pass into `storeName` (must match one of the object store names)\n      tx = db.transaction(storeName, 'readwrite');\n      // save a reference to that object store\n      store = tx.objectStore(storeName);\n\n      // if there's any errors, let us know\n      db.onerror = function(e) {\n        console.log('error', e);\n      };\n\n      // a switch statement to check what the value of the method is.\n      switch (method) { \n        // Both the put and get methods will return the data to wherever we call this idbPromise() function.\n\n        // If it's put, then we run the .put() method on the object store, overwriting any data with the matching _id value from the object and adding it if it can't find a match.       \n        case 'put':\n          store.put(object);\n          resolve(object);\n          break;\n\n        // If it's get, we'll simply get all data from that store and return it. \n        case 'get':\n          const all = store.getAll();\n          all.onsuccess = function() {\n            resolve(all.result);\n          };\n          break;\n        \n          // If the value is delete, we'll delete that item from the object store. This option will come in handy if users want to remove an item from the shopping cart while offline.\n        case 'delete':\n          store.delete(object._id);\n          break;\n          \n        default:\n          console.log('No valid method');\n          break;\n      }\n\n      // when the transaction is complete, close the connection\n      tx.oncomplete = function() {\n        db.close();\n      };\n    };\n\n  });\n};"]},"metadata":{},"sourceType":"module"}